<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" type="text/css" href="my_stylesheet.css" />
    <script src="webgl-debug.js"></script>
    <script src="gl-matrix-min.js"></script>

    <!--source κωδικας του vertex shader -->
    <script id="vShader" type="x-shader/x-vertex">
      //attributes για θεση κορυφων και χρωματος κορυφων
      attribute vec4 aVertexPosition;
      attribute vec2 aTextureCoordinates;

      //uniforms που θα φυλλαξουν τους πινακες μετ/σμου θεσης και καμερας/προοπτικης
      uniform mat4 uTransformMatrix;
      uniform mat4 uPerspectiveViewMatrix;

      varying vec2 vTextureCoordinates;

      //main συναρτηση του vertex shader
      void main(){
      	gl_Position = uPerspectiveViewMatrix * uTransformMatrix * aVertexPosition;
      	vTextureCoordinates = aTextureCoordinates;
      }
    </script>

    <!--source κωδικας του fragment shader -->
    <script id="fShader" type="x-shader/x-fragment">
      precision mediump float;
      varying vec2 vTextureCoordinates;
         uniform sampler2D uSampler;

      //main συναρτηση του fragment shader
      void main() {
      	gl_FragColor = texture2D(uSampler, vTextureCoordinates);
      }
    </script>

    <!--κυριως script σε javascript -->
    <script>
      var gl;
      var canvas;
      var shaderProgram;
      var vertexBuffer;
      var textureCoordinatesAttributePointer;

      //θα χρησιμοποιησουμε 2 buffers χρωματος (αποχρωσεις του μπλε και αποχρωσεις του κοκκινου)
      var textureBuffer;
      var tableTextureBuffer;
      var chairTextureBuffer;
      var vertexPositionAttributePointer; //pointer που δειχνει στο attribute "aVertexPosition"
      var vertexColorAttributePointer; //pointer που δειχνει στο attribute "aVertexColor"
      var indexBuffer;
      var samplerUniformPointer;
      var floorVBuffer; // Vertex - floor
      var floorIBuffer; //Index - floor
      var tableTexture;
      var chairTexture;
      var skyTexture; //texture - sky
      var floorTexture; //texture - floor

      //η μεταβλητη start που ακολουθει, θα χρησιμοποιηθει ετσι ωστε καθε φορα που θα γινεται ανανεωση στη σελιδα
      //να φορτωνονται οι default τιμες για προοπτικη και καμερα χωρις να λαμβανονται υπ'οψιν
      //οι τιμες που "ξεμειναν" στα αντιστοιχα html textboxes, πριν την ανανεωση
      var requestId = 0;
      var totalAngle = 0;
      var totalZ = 0.2;

      //default τιμες για καμερα και προοπτικη
      var viewAngle = (90 * Math.PI) / 180; //γωνια θεασης
      var viewDistance = 5; //ορθογωνια αποσταση καμερας
      var perspDistHigh = 10000; //μακρινο κατωφλι ορατοτητας
      var perspDistLow = 0.01; //κοντινο κατωφλι ορατοτητας

      var numberOfFrames;
      var previousTime;
      var currentTime;
	
      var mouseDown = false; // flag from when mouse is down
      var deltaFresh = false;
      var lastMouseX = null; // last position of the mouse in the canvas
      var lastMouseY = null;
      var currMouseX = null; // current position of the mouse in the canvas
      var currMouseY = null;
      var deltaMouseX = 0; // current - last mouse position
      var deltaMouseY = 0;
      var wheelRadiusFactor = 1; // initial value of the factor for rotation
      var rect;

      var transformUniformPointer; //pointer που δειχνει στο uniform "uTransformMatrix"

      var perspectiveViewUniformPointer; //pointer που δειχνει στο uniform "uPerspectiveViewMatrix"

      //ΑΚΟΛΟΥΘΟΥΝ ΟΙ FUNCTIONS ΠΟΥ ΘΑ ΧΡΗΣΙΜΟΠΟΙΗΘΟΥΝ ΣΤΟ SCRIPT

      function createGLContext(canvas) {
        var context = null;

        context = canvas.getContext("webgl");
        if (!context) context = canvas.getContext("experimental-webgl");
        if (context) {
          context.viewportWidth = canvas.width;
          context.viewportHeight = canvas.height;
        } else {
          alert("Failed to create WebGL context!");
        }
        return context;
      }

      function loadShader(type, shaderSource) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert("Error compiling shader" + gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      function setupShaders() {
        var vertexShaderSource = document.getElementById("vShader").textContent;

        var fragmentShaderSource =
          document.getElementById("fShader").textContent;

        var vertexShader = loadShader(gl.VERTEX_SHADER, vertexShaderSource);
        var fragmentShader = loadShader(
          gl.FRAGMENT_SHADER,
          fragmentShaderSource
        );

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert("Failed to setup shaders");
        }

        gl.useProgram(shaderProgram);

        vertexPositionAttributePointer = gl.getAttribLocation(
          shaderProgram,
          "aVertexPosition"
        );

        gl.enableVertexAttribArray(vertexPositionAttributePointer);

        textureCoordinatesAttributePointer = gl.getAttribLocation(
          shaderProgram,
          "aTextureCoordinates"
        );
        gl.enableVertexAttribArray(textureCoordinatesAttributePointer);

        transformUniformPointer = gl.getUniformLocation(
          shaderProgram,
          "uTransformMatrix"
        );

        perspectiveViewUniformPointer = gl.getUniformLocation(
          shaderProgram,
          "uPerspectiveViewMatrix"
        );
        samplerUniformPointer = gl.getUniformLocation(
          shaderProgram,
          "uSampler"
        );
      }

      function setupBuffers() {
        //ακολουθουν εντολες για τροφοδοτηση των κορυφων του κυβου στον vertexBuffer
        vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        var triangleVertices = [
          //εδρα ΑΒΓΔ
          -1.0,
          1.0,
          1.0,
          1.0, //Α
          -1.0,
          -1.0,
          1.0,
          1.0, //Β
          1.0,
          -1.0,
          1.0,
          1.0, //Γ
          1.0,
          1.0,
          1.0,
          1.0, //Δ

          //εδρα ΑΔΖΕ
          -1.0,
          1.0,
          1.0,
          1.0, //Α
          1.0,
          1.0,
          1.0,
          1.0, //Δ
          1.0,
          1.0,
          -1.0,
          1.0, //Ζ
          -1.0,
          1.0,
          -1.0,
          1.0, //Ε

          //εδρα ΔΓΗΖ
          1.0,
          1.0,
          1.0,
          1.0, //Δ
          1.0,
          -1.0,
          1.0,
          1.0, //Γ
          1.0,
          -1.0,
          -1.0,
          1.0, //Η
          1.0,
          1.0,
          -1.0,
          1.0, //Ζ

          //εδρα ΑΒΘΕ
          -1.0,
          1.0,
          1.0,
          1.0, //Α
          -1.0,
          -1.0,
          1.0,
          1.0, //Β
          -1.0,
          -1.0,
          -1.0,
          1.0, //Θ
          -1.0,
          1.0,
          -1.0,
          1.0, //Ε

          //εδρα ΘΒΓΗ
          -1.0,
          -1.0,
          -1.0,
          1.0, //Θ
          -1.0,
          -1.0,
          1.0,
          1.0, //Β
          1.0,
          -1.0,
          1.0,
          1.0, //Γ
          1.0,
          -1.0,
          -1.0,
          1.0, //Η

          //εδρα ΕΘΗΖ
          -1.0,
          1.0,
          -1.0,
          1.0, //Ε
          -1.0,
          -1.0,
          -1.0,
          1.0, //Θ
          1.0,
          -1.0,
          -1.0,
          1.0, //Η
          1.0,
          1.0,
          -1.0,
          1.0, //Ζ
        ];

        //8 διαφορετικες κορυφες για σχεδιαση τριγωνων που θα φτιαξουν εναν 3d κυβο

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(triangleVertices),
          gl.STATIC_DRAW
        );
        vertexBuffer.itemSize = 4;
        vertexBuffer.numberOfItems = 24;

        //ακολουθουν εντολες για τροφοδοτηση των δεικτων των κορυφων του κυβου στον indexBuffer
        indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        //καθε εδρα του κυβου φτιαχνεται απο 2 τριγωνα, καθε κυβος εχει 6 εδρες οποτε 6*2=12 τριγωνα
        //και καθε τριγωνο εχει 3 κορυφες, οποτε 12*3=36 κορυφες θα δηλωθουν συνολικα στον indexMatrix

        var indexMatrix = [
          //εδρα ΑΒΓΔ
          0, 1, 2, 0, 3, 2,

          //εδρα ΑΔΖΕ
          4, 5, 6, 4, 7, 6,

          //εδρα ΔΓΗΖ
          8, 9, 10, 8, 11, 10,

          //εδρα ΑΒΘΕ
          12, 13, 14, 12, 15, 14,

          //εδρα ΘΒΓΗ
          16, 17, 18, 16, 19, 18,

          //εδρα ΕΘΗΖ
          20, 21, 22, 20, 23, 22,
        ];

        gl.bufferData(
          gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(indexMatrix),
          gl.STATIC_DRAW
        );
        indexBuffer.itemSize = 1;
        indexBuffer.numberOfItems = 36;

        floorVBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, floorVBuffer);

        var floorVMatrix = [
          -1.0, -1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, 1.0,
          1.0, 1.0, -1.0, 1.0,
        ];

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(floorVMatrix),
          gl.STATIC_DRAW
        );
        floorVBuffer.itemSize = 4;
        floorVBuffer.numberOfItems = 4;

        floorIBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, floorIBuffer);

        var floorIMatrix = [0, 1, 2, 2, 1, 3];

        gl.bufferData(
          gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(floorIMatrix),
          gl.STATIC_DRAW
        );
        floorIBuffer.itemSize = 1;
        floorIBuffer.numberOfItems = 6;

        textureBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
        var textureCoordinates = [
          0.0,
          0.0,
          1.0,
          0.0,
          0.0,
          1.0,
          1.0,
          1.0,

          0.0,
          0.0,
          1.0,
          0.0,
          0.0,
          1.0,
          1.0,
          1.0,

          0.0,
          0.0,
          1.0,
          0.0,
          0.0,
          1.0,
          1.0,
          1.0,

          0.0,
          0.0, // texture Buffer
          1.0,
          0.0,
          0.0,
          1.0,
          1.0,
          1.0,

          0.0,
          0.0,
          1.0,
          0.0,
          0.0,
          1.0,
          1.0,
          1.0,

          0.0,
          0.0,
          1.0,
          0.0,
          0.0,
          1.0,
          1.0,
          1.0,
        ];

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(textureCoordinates),
          gl.STATIC_DRAW
        );
        textureBuffer.itemSize = 2;
        textureBuffer.numberOfItems = 24;

        tableTextureBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, tableTextureBuffer);
        var tableTextureCoordinates = [
          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,

          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,

          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,

          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,

          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,

          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
        ];

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(tableTextureCoordinates),
          gl.STATIC_DRAW
        );
        tableTextureBuffer.itemSize = 2;
        tableTextureBuffer.numberOfItems = 24;

        chairTextureBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, chairTextureBuffer);
        var chairTextureCoordinates = [
          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,

          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,

          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,

          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,

          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,

          0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0,
        ];

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(chairTextureCoordinates),
          gl.STATIC_DRAW
        );
        chairTextureBuffer.itemSize = 2;
        chairTextureBuffer.numberOfItems = 24;

        tableTexture = gl.createTexture();
        loadImageForTexture("table.jpg", tableTexture);

        chairTexture = gl.createTexture();
        loadImageForTexture("chair.jpg", chairTexture);

        skyTexture = gl.createTexture();
        loadImageForTexture("sky.jpg", skyTexture);

        floorTexture = gl.createTexture();
        loadImageForTexture("floor.jpg", floorTexture);
      }

      function redraw() {
        var p = 0;

		if(requestId && !mouseDown) {
			var numStepAngle = 1;
			numStepAngle = (numStepAngle * Math.PI) / 180.0;
			totalAngle += numStepAngle;

			// Αποφυγή overflow για το totalAngle
			if (totalAngle >= 2 * Math.PI)
			  // Αν η συνολική γωνία μόλις έγινε (σε ακτίνια) μεγαλύτερη από 360 μοίρες (2π)
			  totalAngle = totalAngle - 2 * Math.PI;
			// κάν'την ίση με την ίδια που είναι μικρότερη από 360 μοίρες
			else if (totalAngle < 0)
			  // αλλιώς αν η συνολική γωνία μόλις έγινε αρνητική
			  totalAngle = totalAngle + 2 * Math.PI; // κάν'την ίση με την ίδια (σε ακτίνια) που είναι θετική

			totalZ += 0.1;
		}
		
        var scaleMat = glMatrix.mat4.create();
        var tranMat = glMatrix.mat4.create();

        var tokens;

        viewDistance = parseFloat(
          document.getElementById("viewDistance").value
        );
        viewAngle =
          (parseFloat(document.getElementById("viewAngle").value) * Math.PI) /
          180.0;


		if( deltaFresh==true && mouseDown){
            totalAngle=totalAngle+deltaMouseX;
            totalZ=totalZ + deltaMouseY/10;
            deltaFresh=false;
        }
        //πινακας μετ/μου καμερας-view
        var vMatrix = glMatrix.mat4.create();
        var c = Math.cos(totalAngle);
        var s = Math.sin(totalAngle);
		
		if(wheelRadiusFactor > 1000) wheelRadiusFactor=1000;
        else if	(wheelRadiusFactor < 0.001)wheelRadiusFactor=0.001;

        //"γεμισμα" του πινακα μετ/σμου καμερας-view
        glMatrix.mat4.lookAt(
          vMatrix,
          [totalZ * c * wheelRadiusFactor, totalZ * s * wheelRadiusFactor, totalZ],
          [0, 0, 0],
          [0, 0, 1]
        );

        //πινακας μετ/μου προοπτικης-perspective
        var pMatrix = glMatrix.mat4.create();
        //"γεμισμα" πινακα μετ/σμου προοπτικης-perspective
        glMatrix.mat4.perspective(
          pMatrix,
          viewAngle,
          1,
          perspDistLow,
          perspDistHigh
        );

        //γινομενο perspective * view
        var pvMatrix = glMatrix.mat4.create();

        //εκτελειται ο πολ/σμος πινακων καμερας και προοπτικης
        //το γινομενο καταληγει στον pvMatrix
        glMatrix.mat4.multiply(pvMatrix, pMatrix, vMatrix);

        //τροφοδοτω το uniform καμερας/προοπτικης μεσω pointer, με τον πινακα γινομενου "καμερα επι προοπτικη"
        gl.uniformMatrix4fv(
          perspectiveViewUniformPointer,
          false,
          new Float32Array(pvMatrix)
        );

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        //table
        var tableTranslationVertices = [
          0,
          0,
          20.5, // epifaneia trapezioy
          9.5,
          9.5,
          10, // mprosta podi
          9.5,
          -9.5,
          10, // aristera podi
          -9.5,
          9.5,
          10, // dejia podi
          -9.5,
          -9.5,
          10, // pisw podi
        ];

        var tableScalingVertices = [
          20 / 2,
          20 / 2,
          1 / 2,
          1 / 2,
          1 / 2,
          20 / 2,
          1 / 2,
          1 / 2,
          20 / 2,
          1 / 2,
          1 / 2,
          20 / 2,
          1 / 2,
          1 / 2,
          20 / 2,
        ];

        // chair
        var chairTranslationVertices = [
          0,
          -10,
          10.25, // epifaneia kareklas
          -4.75,
          -14.75,
          5, // pisw aristera podi
          4.75,
          -14.75,
          5, // pisw de3ia podi
          -4.75,
          -5.25,
          5, // mprosta aristera podi
          4.75,
          -5.25,
          5, // mprosta de3ia podi
          0,
          -14.75,
          15.5, // plati kareklas
        ];

        var chairScalingVertices = [
          10 / 2,
          10 / 2,
          0.5 / 2,
          0.5 / 2,
          0.5 / 2,
          10 / 2,
          0.5 / 2,
          0.5 / 2,
          10 / 2,
          0.5 / 2,
          0.5 / 2,
          10 / 2,
          0.5 / 2,
          0.5 / 2,
          10 / 2,
          10 / 2,
          0.5 / 2,
          10 / 2,
        ];

        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(
          vertexPositionAttributePointer,
          vertexBuffer.itemSize,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.activeTexture(gl.TEXTURE0);
        gl.bindTexture(gl.TEXTURE_2D, tableTexture);
        gl.uniform1i(samplerUniformPointer, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, tableTextureBuffer);
        gl.vertexAttribPointer(
          textureCoordinatesAttributePointer,
          tableTextureBuffer.itemSize,
          gl.FLOAT,
          false,
          0,
          0
        );

        // table
        for (p = 0; p <= 5 * 3; p += 3) {
          gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
          gl.vertexAttribPointer(
            vertexPositionAttributePointer,
            vertexBuffer.itemSize,
            gl.FLOAT,
            false,
            0,
            0
          );
          glMatrix.mat4.fromTranslation(tranMat, [
            tableTranslationVertices[p],
            tableTranslationVertices[p + 1],
            tableTranslationVertices[p + 2],
          ]);
          glMatrix.mat4.fromScaling(scaleMat, [
            tableScalingVertices[p],
            tableScalingVertices[p + 1],
            tableScalingVertices[p + 2],
          ]);
          var transScale = glMatrix.mat4.create();
          glMatrix.mat4.multiply(transScale, tranMat, scaleMat);
          gl.uniformMatrix4fv(
            transformUniformPointer,
            false,
            new Float32Array(transScale)
          );
          gl.drawElements(
            gl.TRIANGLES,
            indexBuffer.numberOfItems,
            gl.UNSIGNED_SHORT,
            0
          );
        }

        // chair
        gl.activeTexture(gl.TEXTURE1);
        gl.bindTexture(gl.TEXTURE_2D, chairTexture);
        gl.uniform1i(samplerUniformPointer, 1);
        gl.bindBuffer(gl.ARRAY_BUFFER, chairTextureBuffer);
        gl.vertexAttribPointer(
          textureCoordinatesAttributePointer,
          chairTextureBuffer.itemSize,
          gl.FLOAT,
          false,
          0,
          0
        );

        for (p = 0; p <= 6 * 3; p += 3) {
          gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
          gl.vertexAttribPointer(
            vertexPositionAttributePointer,
            vertexBuffer.itemSize,
            gl.FLOAT,
            false,
            0,
            0
          );
          glMatrix.mat4.fromTranslation(tranMat, [
            chairTranslationVertices[p],
            chairTranslationVertices[p + 1],
            chairTranslationVertices[p + 2],
          ]);
          glMatrix.mat4.fromScaling(scaleMat, [
            chairScalingVertices[p],
            chairScalingVertices[p + 1],
            chairScalingVertices[p + 2],
          ]);
          var transScale = glMatrix.mat4.create();
          glMatrix.mat4.multiply(transScale, tranMat, scaleMat);
          gl.uniformMatrix4fv(
            transformUniformPointer,
            false,
            new Float32Array(transScale)
          );
          gl.drawElements(
            gl.TRIANGLES,
            indexBuffer.numberOfItems,
            gl.UNSIGNED_SHORT,
            0
          );
        }

        // sky
        gl.activeTexture(gl.TEXTURE2);
        gl.bindTexture(gl.TEXTURE_2D, skyTexture);
        gl.uniform1i(samplerUniformPointer, 2);
        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
        gl.vertexAttribPointer(
          textureCoordinatesAttributePointer,
          textureBuffer.itemSize,
          gl.FLOAT,
          false,
          0,
          0
        );
        glMatrix.mat4.fromScaling(transScale, [5000 / 2, 5000 / 2, 5000 / 2]);
        gl.uniformMatrix4fv(
          transformUniformPointer,
          false,
          new Float32Array(transScale)
        );
        gl.drawElements(
          gl.TRIANGLES,
          indexBuffer.numberOfItems,
          gl.UNSIGNED_SHORT,
          0
        );

        // floor
        gl.bindBuffer(gl.ARRAY_BUFFER, floorVBuffer);
        gl.vertexAttribPointer(
          vertexPositionAttributePointer,
          floorVBuffer.itemSize,
          gl.FLOAT,
          false,
          0,
          0
        );
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, floorIBuffer);

        gl.activeTexture(gl.TEXTURE3);
        gl.bindTexture(gl.TEXTURE_2D, floorTexture);
        gl.uniform1i(samplerUniformPointer, 3);
        gl.bindBuffer(gl.ARRAY_BUFFER, textureBuffer);
        gl.vertexAttribPointer(
          textureCoordinatesAttributePointer,
          textureBuffer.itemSize,
          gl.FLOAT,
          false,
          0,
          0
        );

        glMatrix.mat4.fromScaling(transScale, [50 / 2, 50 / 2, 0]);
        glMatrix.mat4.fromTranslation(tranMat, [0, 0, 0]);
        glMatrix.mat4.multiply(transScale, transScale, tranMat);
        gl.uniformMatrix4fv(
          transformUniformPointer,
          false,
          new Float32Array(transScale)
        );
        gl.polygonOffset(-1, 1);
        gl.enable(gl.POLYGON_OFFSET_FILL);
        gl.drawElements(
          gl.TRIANGLES,
          floorIBuffer.numberOfItems,
          gl.UNSIGNED_SHORT,
          0
        );
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }

      function loadImageForTexture(url, textureObject) {
        var image = new Image();

        image.onload = function () {
          gl.bindTexture(gl.TEXTURE_2D, textureObject);
          gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
          gl.texImage2D(
            gl.TEXTURE_2D,
            0,
            gl.RGBA,
            gl.RGBA,
            gl.UNSIGNED_BYTE,
            image
          );
          gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
          gl.texParameteri(
            gl.TEXTURE_2D,
            gl.TEXTURE_MIN_FILTER,
            gl.LINEAR_MIPMAP_NEAREST
          );
          gl.generateMipmap(gl.TEXTURE_2D);
        };
        image.src = url;
      }

      function startup() {
        canvas = document.getElementById("myGLCanvas");
        var minDimension = Math.min(window.innerWidth, window.innerHeight);
        canvas.width = 0.9 * minDimension;
        canvas.height = 0.9 * minDimension;
        gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas));
        setupShaders();
        setupBuffers();
        gl.clearColor(0.5, 0.5, 0.5, 1.0);

        previousTime = Date.now();
        NumberOfFrames = 0;
		
        gl.enable(gl.DEPTH_TEST);
   
		canvas.onmousedown = handleMouseDown;
        window.onmouseup = handleMouseUp;
        canvas.onmousemove = handleMouseMove;
        canvas.onwheel = handleMouseWheel;
        rect = canvas.getBoundingClientRect();
        startAnim();
      }

      function startAnim() {
        if (!requestId) anim();
      }
      function anim() {
        redraw();
		numberOfFrames++;
                currentTime = Date.now();
                if (currentTime - previousTime >= 1000)
                {
                    document.getElementById("fps").innerHTML = numberOfFrames;
                    numberOfFrames = 0;
                    previousTime = currentTime;
                }
        requestId = window.requestAnimationFrame(anim);
      }
      function stopAnim() {
        window.cancelAnimationFrame(requestId);
        requestId = 0;
      }

      function handleMouseDown(event) {
        mouseDown = true;
        lastMouseX = event.clientX - rect.left;
        lastMouseY = rect.bottom - event.clientY;
        deltaMouseX = 0;
        deltaMouseY = 0;
        deltaFresh = true;
      }

      function handleMouseUp(event) {
        mouseDown = false;
      }

      function handleMouseMove(event) {
        currMouseX = event.clientX - rect.left;
        currMouseY = rect.bottom - event.clientY;
        document.getElementById("mouseX").innerHTML = currMouseX;
        document.getElementById("mouseY").innerHTML = currMouseY;

        if (mouseDown) {
          deltaMouseX = currMouseX - lastMouseX;
          deltaMouseY = currMouseY - lastMouseY;
          deltaFresh = true;
        }
        if (!requestId) redraw();

        lastMouseX = currMouseX;
        lastMouseY = currMouseY;
      }

      function handleMouseWheel(event) {
        if (event.deltaY > 0) wheelRadiusFactor = wheelRadiusFactor * 1.01;
        else wheelRadiusFactor = wheelRadiusFactor * 0.99;

        if (!requestId) redraw();
      }
    </script>
  </head>

  <body onload="startup()">
    <div class="split left">
      <div class="centered">
        <canvas id="myGLCanvas"> </canvas>
      </div>
    </div>
    <br />
    <div class="split right">
      <div class="centered">
        View Angle (degrees):<input type="text" id="viewAngle" value="90" />
        <br />
        View Distance:<input type="text" id="viewDistance" value="20" />
        <br /><br />
        <button class="button" onClick="redraw()">Redraw scene</button>
		<br />
		Frames Rate (Frames Per Second - FPS): <span id="fps">--</span>
		<br />
		Last Canvas Mouse Position x: <span id="mouseX">--</span> ,y: <span id="mouseY">--</span>
        <br />
        Animation
        <button class="button" onclick="startAnim()">Start</button>
        <button class="button" onclick="stopAnim()">Stop</button>
      </div>
    </div>
  </body>
</html>
