<!DOCTYPE html>
<html>
  <head>
    <script src="webgl-debug.js"></script>
    <script src="gl-matrix-min.js"></script>

    <!--source κωδικας του vertex shader -->
    <script id="vShader" type="x-shader/x-vertex">
      //attributes για θεση κορυφων και χρωματος κορυφων
      attribute vec4 aVertexPosition;
      attribute vec4 aVertexColor;

      //uniforms που θα φυλλαξουν τους πινακες μετ/σμου θεσης και καμερας/προοπτικης
      uniform mat4 uTransformMatrix;
      uniform mat4 uPerspectiveViewMatrix;

      varying vec4 vColor;

      //main συναρτηση του vertex shader
      void main(){
      	gl_Position = uPerspectiveViewMatrix * uTransformMatrix * aVertexPosition;
      	vColor = aVertexColor;
      }
    </script>

    <!--source κωδικας του fragment shader -->
    <script id="fShader" type="x-shader/x-fragment">
      precision mediump float;
      varying vec4 vColor;

      //main συναρτηση του fragment shader
      void main() {
      	gl_FragColor = vColor;
      }
    </script>

    <!--κυριως script σε javascript -->
    <script>
      var gl;
      var canvas;
      var shaderProgram;
      var vertexBuffer;

      var colorBuffer;

      var vertexPositionAttributePointer; //pointer που δειχνει στο attribute "aVertexPosition"
      var vertexColorAttributePointer; //pointer που δειχνει στο attribute "aVertexColor"
      var indexBuffer;

      //η μεταβλητη start που ακολουθει, θα χρησιμοποιηθει ετσι ωστε καθε φορα που θα γινεται ανανεωση στη σελιδα
      //να φορτωνονται οι default τιμες για προοπτικη και καμερα χωρις να λαμβανονται υπ'οψιν
      //οι τιμες που "ξεμειναν" στα αντιστοιχα html textboxes, πριν την ανανεωση
      var start = 0;

      //default τιμες για καμερα και προοπτικη
      var viewAngle = (90 * Math.PI) / 180; //γωνια θεασης
      var viewDistance = 5; //ορθογωνια αποσταση καμερας
      var perspDistHigh = 20; //μακρινο κατωφλι ορατοτητας
      var perspDistLow = 0.01; //κοντινο κατωφλι ορατοτητας

      var transformUniformPointer; //pointer που δειχνει στο uniform "uTransformMatrix"

      var perspectiveViewUniformPointer; //pointer που δειχνει στο uniform "uPerspectiveViewMatrix"

      //ΑΚΟΛΟΥΘΟΥΝ ΟΙ FUNCTIONS ΠΟΥ ΘΑ ΧΡΗΣΙΜΟΠΟΙΗΘΟΥΝ ΣΤΟ SCRIPT

      function createGLContext(canvas) {
        var context = null;

        context = canvas.getContext("webgl");
        if (!context) context = canvas.getContext("experimental-webgl");
        if (context) {
          context.viewportWidth = canvas.width;
          context.viewportHeight = canvas.height;
        } else {
          alert("Failed to create WebGL context!");
        }
        return context;
      }

      function loadShader(type, shaderSource) {
        var shader = gl.createShader(type);
        gl.shaderSource(shader, shaderSource);
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
          alert("Error compiling shader" + gl.getShaderInfoLog(shader));
          gl.deleteShader(shader);
          return null;
        }
        return shader;
      }

      function setupShaders() {
        var vertexShaderSource = document.getElementById("vShader").textContent;

        var fragmentShaderSource =
          document.getElementById("fShader").textContent;

        var vertexShader = loadShader(gl.VERTEX_SHADER, vertexShaderSource);
        var fragmentShader = loadShader(
          gl.FRAGMENT_SHADER,
          fragmentShaderSource
        );

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
          alert("Failed to setup shaders");
        }

        gl.useProgram(shaderProgram);

        vertexPositionAttributePointer = gl.getAttribLocation(
          shaderProgram,
          "aVertexPosition"
        );

        gl.enableVertexAttribArray(vertexPositionAttributePointer);

        vertexColorAttributePointer = gl.getAttribLocation(
          shaderProgram,
          "aVertexColor"
        );
        gl.enableVertexAttribArray(vertexColorAttributePointer);

        transformUniformPointer = gl.getUniformLocation(
          shaderProgram,
          "uTransformMatrix"
        );

        perspectiveViewUniformPointer = gl.getUniformLocation(
          shaderProgram,
          "uPerspectiveViewMatrix"
        );
      }

      function setupBuffers() {
        //ακολουθουν εντολες για τροφοδοτηση των κορυφων του κυβου στον vertexBuffer
        vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        var triangleVertices = [
          //εδρα ΑΒΓΔ
          -1.0,
          1.0,
          1.0,
          1.0, //Α
          -1.0,
          -1.0,
          1.0,
          1.0, //Β
          1.0,
          -1.0,
          1.0,
          1.0, //Γ
          1.0,
          1.0,
          1.0,
          1.0, //Δ

          //εδρα ΑΔΖΕ
          -1.0,
          1.0,
          1.0,
          1.0, //Α
          1.0,
          1.0,
          1.0,
          1.0, //Δ
          1.0,
          1.0,
          -1.0,
          1.0, //Ζ
          -1.0,
          1.0,
          -1.0,
          1.0, //Ε

          //εδρα ΔΓΗΖ
          1.0,
          1.0,
          1.0,
          1.0, //Δ
          1.0,
          -1.0,
          1.0,
          1.0, //Γ
          1.0,
          -1.0,
          -1.0,
          1.0, //Η
          1.0,
          1.0,
          -1.0,
          1.0, //Ζ

          //εδρα ΑΒΘΕ
          -1.0,
          1.0,
          1.0,
          1.0, //Α
          -1.0,
          -1.0,
          1.0,
          1.0, //Β
          -1.0,
          -1.0,
          -1.0,
          1.0, //Θ
          -1.0,
          1.0,
          -1.0,
          1.0, //Ε

          //εδρα ΘΒΓΗ
          -1.0,
          -1.0,
          -1.0,
          1.0, //Θ
          -1.0,
          -1.0,
          1.0,
          1.0, //Β
          1.0,
          -1.0,
          1.0,
          1.0, //Γ
          1.0,
          -1.0,
          -1.0,
          1.0, //Η

          //εδρα ΕΘΗΖ
          -1.0,
          1.0,
          -1.0,
          1.0, //Ε
          -1.0,
          -1.0,
          -1.0,
          1.0, //Θ
          1.0,
          -1.0,
          -1.0,
          1.0, //Η
          1.0,
          1.0,
          -1.0,
          1.0, //Ζ
        ];

        //8 διαφορετικες κορυφες για σχεδιαση τριγωνων που θα φτιαξουν εναν 3d κυβο

        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(triangleVertices),
          gl.STATIC_DRAW
        );
        vertexBuffer.itemSize = 4;
        vertexBuffer.numberOfItems = 24;

        //ακολουθουν εντολες για τροφοδοτηση των χρωματων των κορυφων του μπλε κυβου στον colorBuffer
        colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);

        //η μεταβλητη colorVerices       
        var colorVertices = [

          0.368, 0.952, 0.462, 1.0, 0.368, 0.952, 0.462, 1.0, 0.368, 0.952,
          0.462, 1.0, 0.368, 0.952, 0.462, 1.0,


          0.152, 0.568, 0.219, 1.0, 0.152, 0.568, 0.219, 1.0, 0.152, 0.568,
          0.219, 1.0, 0.152, 0.568, 0.219, 1.0,


          0.086, 0.376, 0.129, 1.0, 0.086, 0.376, 0.129, 1.0, 0.086, 0.376,
          0.129, 1.0, 0.086, 0.376, 0.129, 1.0,


          0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0,
          0.0, 1.0,


          0.572, 0.866, 0.619, 1.0, 0.572, 0.866, 0.619, 1.0, 0.572, 0.866,
          0.619, 1.0, 0.572, 0.866, 0.619, 1.0,


          0.058, 0.443, 0.117, 1.0, 0.058, 0.443, 0.117, 1.0, 0.058, 0.443,
          0.117, 1.0, 0.058, 0.443, 0.117, 1.0,
        ];
        gl.bufferData(
          gl.ARRAY_BUFFER,
          new Float32Array(colorVertices),
          gl.STATIC_DRAW
        );
        colorBuffer.itemSize = 4;
        colorBuffer.numberOfItems = 24;

        //ΤΕΛΟΣ ΤΟ "ΓΕΜΙΣΜΑ"

        //ακολουθουν εντολες για τροφοδοτηση των δεικτων των κορυφων του κυβου στον indexBuffer
        indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        //καθε εδρα του κυβου φτιαχνεται απο 2 τριγωνα, καθε κυβος εχει 6 εδρες οποτε 6*2=12 τριγωνα
        //και καθε τριγωνο εχει 3 κορυφες, οποτε 12*3=36 κορυφες θα δηλωθουν συνολικα στον indexMatrix

        var indexMatrix = [
          //εδρα ΑΒΓΔ
          0, 1, 2, 0, 3, 2,

          //εδρα ΑΔΖΕ
          4, 5, 6, 4, 7, 6,

          //εδρα ΔΓΗΖ
          8, 9, 10, 8, 11, 10,

          //εδρα ΑΒΘΕ
          12, 13, 14, 12, 15, 14,

          //εδρα ΘΒΓΗ
          16, 17, 18, 16, 19, 18,

          //εδρα ΕΘΗΖ
          20, 21, 22, 20, 23, 22,
        ];
        gl.bufferData(
          gl.ELEMENT_ARRAY_BUFFER,
          new Uint16Array(indexMatrix),
          gl.STATIC_DRAW
        );
        indexBuffer.itemSize = 1;
        indexBuffer.numberOfItems = 36;
      }

      function redraw() {
        start++; //αν εκτελεστει η redraw αυξανεται ο μετρητης start

        //local μεταβλητη στην οποια θα φυλαχθει η επιλογη απο το html radio button ΣΕ ΜΟΡΦΗ TOKENS
        var tokens;

        //οι παρακατω μεταβλητες (fx εκ του xfactor, fy εκ του yfactor, fz εκ του zfactor) θα χρησιμοποιηθουν
        //για την τοποθετηση της καμερας, αναλογα με την επιλογη του χρηστη απο τα html radio buttons
        //και αρχικοποιουνται με την τιμη 1
        var fx = (fy = fz = 1);

        //αν η σελιδα δεν εχει ανανεωθει (αν ανανεωθηκε τοτε start == 1) τοτε "λαβε υπ'οψιν σου τις επιλογες του χρηστη"
        if (start > 1) {
          tokens = document
            .querySelector('input[name="position"]:checked')
            .value.split("-");

          if (tokens[0] == "Left") fx = -1;
          if (tokens[1] == "Front") fy = -1;
          if (tokens[2] == "Bottom") fz = -1;

          viewDistance = parseFloat(
            document.getElementById("viewDistance").value
          );
          perspDistHigh = viewDistance * 4;
          viewAngle =
            (parseFloat(document.getElementById("viewAngle").value) * Math.PI) /
            180.0;
        }

        //πινακας μετ/μου καμερας-view
        var vMatrix = glMatrix.mat4.create();
        //"γεμισμα" του πινακα μετ/σμου καμερας-view
        glMatrix.mat4.lookAt(
          vMatrix,
          [fx * viewDistance, fy * viewDistance, fz * viewDistance],
          [0, 0, 0],
          [1, 0, 0]
        );

        //πινακας μετ/μου προοπτικης-perspective
        var pMatrix = glMatrix.mat4.create();
        //"γεμισμα" πινακα μετ/σμου προοπτικης-perspective
        glMatrix.mat4.perspective(
          pMatrix,
          viewAngle,
          1,
          perspDistLow,
          perspDistHigh
        );

        //γινομενο perspective * view
        var pvMatrix = glMatrix.mat4.create();

        //εκτελειται ο πολ/σμος πινακων καμερας και προοπτικης
        //το γινομενο καταληγει στον pvMatrix
        glMatrix.mat4.multiply(pvMatrix, pMatrix, vMatrix);

        //τροφοδοτω το uniform καμερας/προοπτικης μεσω pointer, με τον πινακα γινομενου "καμερα επι προοπτικη"
        gl.uniformMatrix4fv(
          perspectiveViewUniformPointer,
          false,
          new Float32Array(pvMatrix)
        );

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        //τροφοδοτω το attribute aVertexPosition (vertex shader) μεσω pointer
        //με τα περιεχομενα του buffer κορυφων (vertexBuffer)
        gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
        gl.vertexAttribPointer(
          vertexPositionAttributePointer,
          vertexBuffer.itemSize,
          gl.FLOAT,
          false,
          0,
          0
        );

        //τροφοδοτω το attribute aVertexColor (vertex shader) μεσω pointer
        //με τα περιεχομενα του buffer χρωματων (colorBuffer)
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.vertexAttribPointer(
          vertexColorAttributePointer,
          colorBuffer.itemSize,
          gl.FLOAT,
          false,
          0,
          0
        );

        //"ενεργοποιηση" του buffer με τους δεικτες κορυφων (indexBuffer)
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);

        //προς το παρον ο πινακας μετ/σμου θεσης (uniform) που υπαρχει στον vertex shader
        //θα γεμιστει με τον μοναδιαιο πινακα ετσι ωστε να μην εκτελεστει στον κυβο καποιος
        //επιπλεον μετασχηματισμος περαν του μετ/μου καμερας/προοπτικης
        var temp = glMatrix.mat4.create();

        gl.uniformMatrix4fv(
          transformUniformPointer,
          false,
          new Float32Array(temp)
        );
        gl.drawElements(
          gl.TRIANGLES,
          indexBuffer.numberOfItems,
          gl.UNSIGNED_SHORT,
          0
        );
      }

      function startup() {
        canvas = document.getElementById("myGLCanvas");
        var minDimension = Math.min(window.innerWidth, window.innerHeight);
        canvas.width = 0.9 * minDimension;
        canvas.height = 0.9 * minDimension;
        gl = WebGLDebugUtils.makeDebugContext(createGLContext(canvas));
        setupShaders();
        setupBuffers();
        gl.clearColor(0.5, 0.5, 0.5, 1.0);

        gl.enable(gl.DEPTH_TEST);
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        redraw();
      }
    </script>
  </head>

  <body onload="startup()">
    <canvas id="myGLCanvas"> </canvas>

    <br />
    View Angle (degrees):<input type="text" id="viewAngle" value="90" />
    <br />
    View Distance:<input type="text" id="viewDistance" value="5" /> <br /><br />
    <div id="radioButtons">
      <input
        type="radio"
        name="position"
        value="Left-Front-Top"
        checked="checked"
      />Left Front Top<br />
      <input type="radio" name="position" value="Left-Front-Bottom" />Left Front
      Bottom<br />
      <input type="radio" name="position" value="Left-Back-Top" />Left Back
      Top<br />
      <input type="radio" name="position" value="Left-Back-Bottom" />Left Back
      Bottom<br />
      <input type="radio" name="position" value="Right-Front-Top" />Right Front
      Top<br />
      <input type="radio" name="position" value="Right-Front-Bottom" />Right
      Front Bottom<br />
      <input type="radio" name="position" value="Right-Back-Top" />Right Back
      Top<br />
      <input type="radio" name="position" value="Right-Back-Bottom" />Right Back
      Bottom<br />
    </div>
    <button onClick="redraw()">Redraw scene</button>
  </body>
</html>
